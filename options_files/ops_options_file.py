import os
import re
import configparser

from abstraction.abstraction import convert_options_to_rocksdb
from utils.constants import ABSTRACTION, DEFAULT_OPTION_FILE_DIR, INITIAL_OPTIONS_FILE_NAME, OPTIONS_FILE_DIR
from utils.filter import BLACKLIST, DB_BENCH_ARGS
from utils.parse import dict_to_configparser, configparser_to_string
from utils.utils import log_update, log_gpt_response
from gpt.gpt_request import request_gpt_with_structured_output
from utils.options_list import RocksDBOptions

def parse_gpt_text_to_dict(gpt_output_text):
    '''
    Function to parse the gpt output text with filters

    Parameters:
    - gpt_output_text (str): The output generated by gpt

    Returns:
    - options_dict (dict): A dictionary containing the parsed data
    '''
    if ABSTRACTION:
        gpt_output_text = convert_options_to_rocksdb(gpt_output_text)

    options_dict = {}

    for line in gpt_output_text.split("\n"):
        # Ignore lines starting with '#' as they are comments
        if not line.startswith('#'):
            # Split the line at the first '=' and strip whitespace
            parts = line.split(':', 1)
            if len(parts) == 1:
                parts = line.split('=', 1)
            if len(parts) == 2:
                # filters options that start with { - k
                if '{' not in parts[1].strip():
                    # filters options that are in the blacklist
                    if parts[0].strip() not in BLACKLIST:
                        key, value = parts[0].strip().strip("--"), parts[1].strip().split('#')[0].strip()
                        options_dict[key] = value

    return options_dict

def cleanup_options_file(gpt_options_text, prev_db_bench_args):
    """
    Function to clean up the options file generated by GPT
    - replace the values of the options in the original options file with the values generated by GPT-4
        eliminate 2 secnarios:
        1. ```ini<code>```
        2. ```<code>...``` w/ multiple code blocks

    Parameters:
    - gpt_options_text: string containing the options file generated by GPT-4

    Returns:
    - config_string: string containing the options file in the original format
    """
    
    system_content = None
    user_contents = ["Extract the different options that are being tweaked in the following text. Set the value to Null if the input does not provide it.\n\n" + gpt_options_text]
    assistant_content = None
    response = request_gpt_with_structured_output(system_content, user_contents, assistant_content, RocksDBOptions, 1.0)

    log_gpt_response(user_contents, str(response.model_dump()))

    gpt_output_dict = {}
    for key, value in response.model_dump().items():
        if value is None:
            continue
        if len(value) > 1:
            for k, v in value.items():
                if v is not None:
                    gpt_output_dict[k] = v

    changed_value = {}
    clean_output_dict = parse_option_file_to_dict(open(f"{OPTIONS_FILE_DIR}").read())

    args_dict = parse_db_bench_args_to_dict(prev_db_bench_args)

    # Update the original options with GPT-4 generated value
    for key, value in gpt_output_dict.items():
        if key in DB_BENCH_ARGS:
            if value == "-1":
                continue
            if key not in args_dict or args_dict[key] != value:
                args_dict[key] = value
                changed_value[key] = value
            continue
        
        for internal_dict in clean_output_dict:
            if key in clean_output_dict[internal_dict]:
                if clean_output_dict[internal_dict][key] != gpt_output_dict[key]:
                    clean_output_dict[internal_dict][key] = gpt_output_dict[key]
                    changed_value[key] = gpt_output_dict[key]
                # else:
                #     same value
                #     log_update()
            # else:
            #     log_update(f"Key: {key} is not an RocksDB options")

    # Convert dictionary to configparser
    config_parser = dict_to_configparser(clean_output_dict)
    config_string = configparser_to_string(config_parser)
    new_bench_args = [f"--{k}={v}" for k, v in args_dict.items()]

    # Save to a file
    with open(f"{OPTIONS_FILE_DIR}", "w") as file:
        file.write(config_string)
    return config_string, changed_value, new_bench_args

def parse_db_bench_args_to_dict(db_bench_args):
    '''
    Function to parse the db_bench arguments to a dictionary

    Parameters:
    - db_bench_args (list): The db_bench arguments

    Returns:
    - parsed (dict): A dictionary containing the parsed data
    '''
    parsed = {}
    for db_bench_arg in db_bench_args:
        key, value = db_bench_arg.strip().strip("--").split("=")
        parsed[key] = value
    return parsed

def get_initial_options_file():
    '''
    Get the initial options file

    Parameters:
    - None

    Returns:
    - options (str): The initial options file
    - reasoning (str): The reasoning behind the options file
    '''
    initial_options_file_path = os.path.join(DEFAULT_OPTION_FILE_DIR,
                                        INITIAL_OPTIONS_FILE_NAME)
    with open(initial_options_file_path, "r") as f:
        options = f.read()

    reasoning = f"Initial options file: {initial_options_file_path}"

    return options, reasoning


def parse_option_file_to_dict(option_file):
    '''
    Function to parse the given option file to a dictionary

    Parameters:
    - option_file (str): The path to the option file

    Returns:
    - parsed (dict): A dictionary containing the parsed data
    '''
    pat = re.compile("(.*)\s*([#].*)?")
    config = configparser.ConfigParser()
    config.read_string(option_file)
    parsed = {section: dict(config.items(section))
              for section in config.sections()}
    for section_name, section in parsed.items():
        for k, v in section.items():
            m = pat.match(v)
            section[k] = m[1]
    return parsed
